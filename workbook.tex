% !TeX spellcheck = en_US
\documentclass[12pt,a4paper,oneside]{book}  
% oneside or openright

%% ***************************************************************
%%    PACKAGES
\usepackage{lmodern}         % font package.
\usepackage[T1]{fontenc}     % define T1 charset for out files.
\usepackage[english]{babel}  % italian latex typo conventions.
\usepackage[utf8]{inputenc}  % italian symbols.
\usepackage{csquotes}        % needed by babel.
\usepackage{amsmath}         % math features.
\usepackage{amsthm}          % math theorems.
\usepackage{amssymb}         % math symbols.
\usepackage{amsbsy}          % math bold.
\usepackage{listings}        % embed programming language in latex.
\usepackage{stmaryrd}        % symbols for theoretical computer science.
\usepackage{hhline}          % better horizontal lines in tabulars and arrays.
%%\usepackage{vmargin}         % various page dimensions.
\usepackage{hyperref}        % hypertext support.
\usepackage{makeidx}         % for creating indexes.
\usepackage{nicefrac}        % inline fractions.
\usepackage{marginnote}      % notes in the margin, even where \marginpar fails.
\usepackage{xr}              % references to other latex documents.
\usepackage{subfiles}        % multifile support.
\usepackage{geometry}        % interface for document dimension.
\usepackage{graphicx}        % enhanced support for graphics.
\usepackage{fancyhdr}        % extensive control of page headers and footers.
\usepackage{lipsum}          % generate dummy text.
\usepackage[
backend=biber,
style=numeric,
citestyle=numeric  % numeric, alphabetic
]{biblatex}                  % bib management. %bibtex
\usepackage{minitoc}         % table of contents per chapter.
%\usepackage{titlesec}        % change titles size.
\usepackage{algorithm}       % algorithm block.
\usepackage{algcompatible}
\usepackage{algpseudocode}   % style for (autoimported) package algorithmicx.
\usepackage{float}           % float management.
\usepackage[toc,page]{appendix}  % appendix.
\usepackage{tcolorbox}
%\usepackage{minted}
\usepackage{tikz}            % flow chart.
%\usepackage{tocvsec2}        % numbering chapter fix.
\usepackage{enumitem}        % enums.
%\usepackage{subcaption}      % needed by nested figures.
%\usepackage{showframe}      % DEBUG: shows page frames.
\usepackage{xcolor}

%% ***************************************************************
%%    RESOURCES
\input{prooftree.tex}
\input{macros.tex}

%% ***************************************************************
%%    CONFIGURATIONS
\usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
    decorations.pathreplacing,decorations.pathmorphing,shapes,%
    matrix,shapes.symbols}
\tikzset{
    % flow chart
    >=stealth',
    punktchain/.style={
        rectangle,
        rounded corners,
        % fill=black!10,
        draw=black, very thick,
        text width=10em,
        minimum height=3em,
        text centered,
        on chain},
    line/.style={draw, thick, <-},
    element/.style={
        tape,
        top color=white,
        bottom color=blue!50!black!60!,
        minimum width=8em,
        draw=blue!40!black!90, very thick,
        text width=10em,
        minimum height=3.5em,
        text centered,
        on chain},
    every join/.style={->, thick,shorten >=1pt},
    decoration={brace},
    tuborg/.style={decorate},
    tubnode/.style={midway, right=2pt},
}

%% ***************************************************************
%%    OPENING
\title{Workbook \\ Master Degree in Computer Science}
\author{Luca Parolari\footnote{\href{mailto:luca.parolari23@gmail.com}{luca.parolari23@gmail.com}}}


%% ###############################################################
%%                            DOCUMENT
%% ###############################################################
\begin{document}

\maketitle
\tableofcontents

\part{AA 2019-2020}

% *********************
\chapter{Software Analysis and Verification}

\section{Semantics}

\subsection{Exercise 1.7}

\begin{exercise}{(1.7)}
    \label{ex_1_7}
    Prove that the equations of Equation \ref{eq_ex_1_7} define a total function $\calA$ in $\AExp \to (\ST \to \mathrm{Z})$: First argue that it is sufficient to prove that for each $a \in \AExp$ and each $s \in \ST$ there is exactly one value $v \in Z$ such that $\denotA{a}{s} = v$. Next use structural induction on the arithmetic expressions to prove that this is indeed the case.
    
    \begin{equation}
    \label{eq_ex_1_7}
    \begin{split}
    \denotA{n}{s} &= \denotN{n} \\
    \denotA{x}{s} &= s x \\
    \denotA{a_1+a_2}{s} &= \denotA{a_1}{s} + \denotA{a_2}{s} \\
    \end{split}
    \end{equation}
    
    \begin{proof}
        We have to prove that
        \[
        \forall a \in \AExp \itc \forall s \in \ST: \exists v \in \mathrm{Z} \st \denotA{a}{s} = v
        \]
        and we can do it by structural induction on $a$.
        
        \begin{itemize}
            \item Base case $a \equiv n$. $\denotA{n}{s} = \denotN{n}$ holds assuming $\denotN{n}$ is a total function.
            \item Base case $a \equiv x$. $\denotA{x}{s} = s x$ holds by definition of $s$ ($\fund{s}{\Var}{\Natural}$).
            \item Inductive case $a \equiv a_1 + a_2$. We can apply the definition for this case and we obtain
            \[
            \forall a_1, a_2 \in \AExp \itc \forall s \in \ST: \exists v \in \mathrm{Z} \st \denotA{a_1 + a_2}{s} = v
            \]
            and this, by structural induction and because $+$ is a total function, holds.
        \end{itemize}
    \end{proof}
    
\end{exercise}

\subsection{Exercise 1.8}

\begin{exercise}{(1.8)}
    Assume that $s\ x = 3$ and determine $\denotB{\notop(x = 1)}{s}$.
    
    \begin{proof}
        We have to apply rules from our semantics in order to get the result.
        
        TODO
    \end{proof}
\end{exercise}

\subsection{Exercise 1.9}

\begin{exercise}{(1.9)}
    Prove that the denotation semantic function for booleans $\calB$, $\fund{\calB}{\BExp}{(\ST \to \mathrm{T})}$ is total.
    
    \begin{proof}
        Identical to \ref{ex_1_7}
    \end{proof}
\end{exercise}

\subsection{Exercise 1.9}

\begin{exercise}{(1.9)}
    TODO
\end{exercise}

\subsection{Exercise 1.12}

\begin{exercise}
    Let $s$ and $s'$ be two states satisfying that $s x = s' x$ for all $x$ in $FV(b)$. Prove that $\denotB{b}{s} = \denotB{b}{s'}$. $\FV$ is defined in Definition \ref{ex_1_12_fv}.
    
    \begin{proof}
        We assume that this sentences holds for $\calA$. (This is proved in \ref{ex_1_12_lemma}). We have to prove that
        \[
        \forall b \in \BExp \itc \forall s, s' \in \ST \itc \forall x \in \FV(a) \itc sx = s'x \Rightarrow \denotB{b}{s} = \denotB{b}{s'}
        \]
        
    \end{proof}
    
\end{exercise}

\begin{definition}
    \label{ex_1_12_fv}
    Define FV \todo{define FV}
\end{definition}

\begin{lemma}
    \label{ex_1_12_lemma}
    \[
    \forall a \in \AExp \itc \forall s, s' \in \ST \itc \forall x \in \FV(a) \itc sx = s'x \Rightarrow \denotA{a}{s} = \denotA{a}{s'}
    \]
    
    \begin{proof}
        We have to prove that
        \[
        \forall a \in \AExp \itc \forall s, s' \in \ST \st sx = s'x \Rightarrow \denotA{b}{s} = \denotA{b}{s'}
        \]
        and we can do it by structural induction on $b$.
        
        \begin{itemize}
            \item Base case $a \equiv n$. It's trivial to note that $\denotA{n}{s} = \denotN{n} = n = n = \denotN{n} = \denotB{n}{s'}$.
            \item Base case $a \equiv x$. In this case we have
        \end{itemize}
    \end{proof}
\end{lemma}

% *********************
\chapter{Machine Learning}

\section{Decision Trees}

\subsection{Exercise: build a decision tree}

\begin{exercise}
    Using algorithm \emph{ID3} build the decision trees for logical AND, OR and XOR.
    
    \begin{proof} (AND)
        Define the examples set $S$ as
        \begin{center}
            \begin{tabular}{ c c c c }
                \textbf{Examples} & \textbf{$a_1$} & \textbf{$a_2$} & \textbf{Output} \\
                $E_1$ & 0 & 0 & $\ffv$ \\ 
                $E_2$ & 0 & 1 & $\ffv$ \\  
                $E_3$ & 1 & 0 & $\ffv$ \\
                $E_4$ & 1 & 1 & $\ttv$
            \end{tabular}
        \end{center}
        where $a_1, a_2$ are attributes in $A$, $\ttv, \ffv$ are the two possible classes and $0, 1$ are the two possible values.
        
        Now we can apply the algorithm \emph{ID3}.
        \begin{itemize}
            \item \textbf{Step 1} We create the root node $T$. The two tests fail: examples in $S$ are not in the same class and $A$ is not empty. So we have to chose $a \in A$ as the best attribute in $A$.
            
            In order to chose the best attribute in $A$ we must calculate the \emph{entropy} (i.e., a measure of the disorder) and the \emph{information gain} (i.e., the expected reduction of entropy for a given set).
            
            Entropy is
            \[
            E(S) = - \sum_{c=1}^{m} p_c \log(p_c)
            \]
            where $p_c = \frac{|S_c|}{|S|}$, but for a binary classification it becomes
            \[
            E(S) = - p_- \log(p_-) - p_+ \log(p_+)
            \]
            
            And the gain
            \[
            G(S,a) = E(S) - \sum_{v\in V(a)} \frac{|S_{a=v}|}{|S|} E(S_{a=v})
            \]
            
            So, instancing the two formulas on our data we obtain
            \[
            p_- = \frac{|S_-|}{|S|} = \frac{3}{4} \qquad p_+ = \frac{|S_+|}{|S|} = \frac{1}{4}
            \]
            and
            \[
            E(S) = - \frac{3}{4} \log\big(\frac{3}{4}\big) - \frac{1}{4} \log\big(\frac{1}{4}\big) = 0.244
            \]
            From this, we can calculate the gain as
            \begin{equation*}
            \begin{split}
            G(S, a_1) &= 0.244 - \Big( \big(\frac{|S_{a_1=0}|}{|S|} E(S_{a_1=0})\big) + \big(\frac{|S_{a_1=1}|}{|S|} E(S_{a_1=1})\big) \Big) \\
            &= 0.244 - \Big( \big(\frac{2}{4} E(S_{a_1=0})\big) + \big(\frac{2}{4} E(S_{a_1=1})\big) \Big) \\
            &= 0.244 - (0 + 0.25) \\
            &= -0.006  \law{\color{red}{WTF??}}
            \end{split}
            \end{equation*}
            \fixme{Non può essere negativo!}
            
            From the above we can chose the attribute $a_1$, set it as $T$ and make two recursive call:
            \begin{itemize}
                \item $ID3(S_{a_1=0}, A \setdiff \{a_1\})$
                \item $ID3(S_{a_1=1}, A \setdiff \{a_1\})$
            \end{itemize}
            
            \item \textbf{Step 2} First recursive call from Step 1. We have $S = \{ \langle 0,0,\ffv \rangle, \langle 0,1,\ffv \rangle \}$, $A = \{a_2\}$. We create a new root node $T$ and we can assign $\ffv$ to it because the elements in $S$ have the same class.
            
            \item \textbf{Step 3} Second recursive call from Step 1. We have $S = \{ \langle 1,0,\ffv \rangle, \langle 1,1,\ttv \rangle \}$, $A=\{a_2\}$. We create a new root node $T$ and assign $a_2$ to it because $a_2$ is the last attribute in $A$ (i.e., the optimal one), then we can make the recursive call:
            \begin{itemize}
                \item $ID3(S_{a_2=0}, A \setdiff \{a_2\})$
                \item $ID3(S_{a_2=1}, A \setdiff \{a_2\})$
            \end{itemize}
            
            \item \textbf{Step 4} First recursive call from Step 3. We have $S=\{\langle 1,0,\ffv \rangle \}$ and for this we can assign $\ffv$ to $T$ since it is the last element in $S$, making a leaf.
            
            \item \textbf{Step 5} Second recursive call from Step 3. We have $S=\{ \langle 1,1,\ttv \rangle \}$ and for this we can assign $\ttv$ to $T$ since it is the last element in $S$, making a leaf.
        \end{itemize}
        
        \begin {tikzpicture}[-latex ,auto ,node distance =2 cm and 2cm, on grid, semithick, state/.style ={ circle ,top color =white , bottom color = white, draw, black , text=black, minimum width =1 cm}]
        \node[state] (A) {$a_1$};
        \node[state] (B) [below left =of A] {$\ffv$};
        \node[state] (C) [below right =of A] {$a_2$};
        \node[state] (D) [below left =of C] {$\ffv$};
        \node[state] (E) [below right =of C] {$\ttv$};
        \path (A) edge node {$0$} (B);
        \path (A) edge node {$0$} (C);
        \path (C) edge node {$0$} (D);
        \path (C) edge node {$1$} (E);
    \end{tikzpicture}
    
\end{proof}
\end{exercise}

\begin{exercise}
Using algorithm \emph{ID3} build the decision trees for logical AND, OR and XOR. This time only three examples are given.

\begin{proof} (AND)
    Define the examples set $S$ as
    \begin{center}
        \begin{tabular}{ c c c c }
            \textbf{Examples} & \textbf{$a_1$} & \textbf{$a_2$} & \textbf{Output} \\
            $E_1$ & 0 & 0 & $\ffv$ \\
            $E_2$ & 0 & 1 & $\ffv$ \\
            $E_4$ & 1 & 1 & $\ttv$ \\
        \end{tabular}
    \end{center}
    where $a_1, a_2$ are attributes in $A$, $\ttv, \ffv$ are the two possible classes and $0, 1$ are the two possible values.
    
    Now we can apply the algorithm \emph{ID3}.
    \begin{itemize}
        \item \textbf{Step 1} We create the root node $T$. The two tests fail: examples in $S$ are not in the same class and $A$ is not empty. So we have to chose $a \in A$ as the best attribute in $A$.
        
        For simplicity this part is skipped and $a_1$ is chosen as the optimal attribute.
        
        From the above we can chose the attribute $a_1$, set it as $T$ and make two recursive call:
        \begin{itemize}
            \item $ID3(S_{a_1=0}, A \setdiff \{a_1\})$
            \item $ID3(S_{a_1=1}, A \setdiff \{a_1\})$
        \end{itemize}
        
        \item \textbf{Step 2} First recursive call from Step 1. We have $S = \{ \langle 0,0,\ffv \rangle, \langle 0,1,\ffv \rangle \}$, $A = \{a_2\}$. We create a new root node $T$ and we can assign $\ffv$ to it because the elements is $S$ are have the same class.
        
        \item \textbf{Step 3} Second recursive call from Step 1. We have $S = \{ \langle 1,1,\ttv \rangle \}$, $A=\{a_2\}$. We create a new root node $T$ and assign $\ttv$ to it because elements in $S$ have the same class.
    \end{itemize}
\end{proof}
\end{exercise}

% *********************
\chapter{Advanced Topics on Programming Languages}

\section{Esercizio 1.1}

\begin{exercise}
    Solve the follogin exercises on high-order functions. \todo{Translate}
    \begin{itemize}
        \item write a term that represent an high-order function (i.e., takes another function as input). Scrivere inoltre un
        programma che usa una funzione higher.
        \item Scrivere una funzione che restituisce una funzione.
    \end{itemize}

\begin{proof}
    Parte 1:
    \begin{verbatim}
    -- high order
    fn x.x
    
    -- apply func arg
    --   Apply the function `func` to argument `arg`.
    fn x. (fn y. (x y) 1) fn z. z+1
    \end{verbatim}
    
    Parte 2:
    \begin{verbatim}
    fn x.x fn y.y+1
    \end{verbatim}
    
\end{proof}

\end{exercise}

\section{Esercizio 1.4}

\begin{exercise}
    Definire formalmente la nozione di sottotermini di un termine M del nostro linguaggio.
    \begin{proof}
        ???
    \end{proof}
\end{exercise}

\section{Esercizio Extra 1}

\begin{exercise}
    Definire la semantica dell'applicazione con \emph{call-by-name}.
    \begin{proof}
        \begin{equation}
        \rulename{BETA.N}
        \prooftree
        \justifies
        fn \ x .\ M\ N \to M \{ x := N \}
        \endprooftree
        \end{equation}
        
        \begin{equation}
        \rulename{APP.N}
        \prooftree
        M \to M'
        \justifies
        M \ N \to M' \ N
        \endprooftree
        \end{equation}
    \end{proof}
\end{exercise}

\section{Esercizio Extra 2}

\begin{exercise}
    Dimostrare formalmente che la valutazione (esecuzione) di un programma è deterministica. Se $M \to M'$ e $M \to M''$ allora $M' = M''$.
    
    \begin{proof}
        Si enuncia prima, in modo formale, la proposizione.
        \[
        \forall M, M', M'' \in Term: M \to M' \land M \to M'' \Rightarrow M' = M''
        \]
        Ciò viene mostrato per induzione sulla struttura di M.
        
        \begin{itemize}
            \item Caso base. Prendiamo in esame il caso $M = true$.
            
            Applicando l'enunciato abbiamo 
            \[
            true \not\to M' \land true \not\to M'' \Rightarrow M' = M''
            \]
            ma questo è banalmente vero, visto che $false \Rightarrow
            true$ è $true$.
            
            Gli altri casi sono analoghi.
            
            \item Passo induttivo. Prendiamo in esame $M = N_1 + N_2$.
            
            Applicando l'enunciato ottenuamo
            \[
            N_1 + N_2 \to N' \land N_1 + N_2 \to N'' \Rightarrow N' = N''
            \]
            
            Per ipotesi induttiva sappiamo che vale
            \begin{equation*}
            \begin{split}
            N_1 \to N_1' \land N_1 \to N_1'' & \Rightarrow N_1' = N_1'' \\
            N_2 \to N_2' \land N_2 \to N_2'' & \Rightarrow N_2' = N_2''
            \end{split}
            \end{equation*}
            e quindi
            \[
            N' = N'' \Leftrightarrow N_1' + N_2' = N_1'' + N_2''
            \]
            
            A questo punto, sapendo che anche la somma è un'operazione
            deterministica concludo che $M' = M''$.
        \end{itemize}
    \end{proof}
\end{exercise}

\section{Exercise 3.2}

\todo{Add this exercise}

\section{Exercise 3.3}

\todo{Add this exercise}

\section{Exercise 3.14}

\begin{exercise}
    Prove that if $\Gamma \vdash M: \tT$ is derivable then $\FV(M) \subseteq \dom(\Gamma)$.

    \begin{proof}
        By structural induction on $M$.
        
        \begin{itemize}
            \item Case $M = \true$. $M$ is derivable using $\mathrm{T-TRUE}$ rule. Then we know that $\FV(M) = \FV(true) = \emptyset$ by definition and $\emptyset \subseteq \dom(\Gamma)$, thus $\FV(M) \subseteq \dom(\Gamma)$.
            \item Case $M = \false$ and $M=n$ are identical to case $M = \true$.
            \item Case $M = x$. $M$ is derivable using $\mathrm{T-VAR}$ and the rule is applicable only if $x \in \Gamma$. Then we know $\FV(M) = \FV(x) = \{x\}$. Thus, $\FV(M) = \FV(x) \subseteq \dom(\Gamma)$.
            \item Case $M = M_1 + M_2$. $M$ is derivable by $\mathrm{T-SUM}$. 
            \[
                \rulename{T-SUM}
                \prooftree
                  \Gamma \vdash M_1:\mathrm{Nat} \qquad \Gamma \vdash M_2:\mathrm{Nat}
                  \justifies
                  \Gamma \vdash M_1+M_2 :\mathrm{Nat}
                \endprooftree
            \]
            Then we know that 
            \[
                \FV(M) = \FV(M_1 + M_2) = \FV(M_1) \cup \FV(M_2)
            \]
            and by the inductive hypothesis 
            \[
                \FV(M_1) \in \Gamma \land \FV(M_2) \in \Gamma
            \]
            so
            \[
                \FV(M_1) \cup \FV(M_2) \in \Gamma
            \]
            \item Case $M = \condif{M_1}{M_2}{M_3}$ and $M = M_1 M_2$. Can be proved as done in $M = M_1 + M_2$ case.
            \item Case $M = fx:\tT_1.M:\tT_1 \to \tT_2$. $M$ is derivable using $\mathrm{T-FUN}$
            \[
                \rulename{T-FUNC}
                \prooftree
                    \Gamma,x:\tT_1 \vdash M:\tT_2
                \justifies
                    \Gamma \vdash f x:\tT_1 . M:\tT_1 \to \tT_2
                \endprooftree
            \]
            We know that $\FV(M) = \FV(fx:\tT_1.M:\tT_1 \to \tT_2) = \FV(M) \setminus \{x\}$. Let $\Gamma' = \Gamma, x$. By the inductive hypothesis we know that $\FV(M) \subseteq \Gamma = \Gamma' \setminus \{x\}$, thus $\FV(M) \subseteq \dom(\Gamma')$.
            
        \end{itemize}
    \end{proof}
\end{exercise}


% *********************
\chapter{Computability}

\section{URM calcolabilità}

\begin{exercise}
    Let $URM^-$ be a $URM$-machine without the jump instruction.
    Prove that $\calC^- \not\subseteq \calC$. (Note: for simplicity consider only unary functions, $f: \Nset \to \Nset$)
    
    \begin{proof}
        Intuitively, a $URM^-$ program must stop in a finite number of steps $l(P)$ (i.e., the length of the program).
        For this reason we can compute only functions like
        \[
        f(x) = c
        \]
        or
        \[
        f(x) = x + c
        \]
        
        We need to prove that the output for an $URM^-$ program (i.e., the content of the first register) is in the desidered form.
        However, we need to prove that all registers are in the desidered form.\footnote{If we prove the proposition proving the condition only for the first register, when treating the transfer instruction we cannot say anything on the content of other registers, for this we cannot end the proof.}
        
        So, we want to prove
        \[ r_i(x, j) = c \]
        or
        \[ r_i(x, j) = x + c \]
        where $x$ is the input and $j$ is the number of steps and holds for each register $i$.
        
        We can prove that by induction on $j$.
        
        \begin{itemize}
            \item Base case. $j = 0$. 
            \begin{itemize}
                \item $r_1(x, 0) = x$ or $r_1(x, 0) = 0$,
                \item $r_{i > 1} (x, 0) = 0$.
            \end{itemize}
            
            \item Inductive case. $j \to j + 1$.
            
            We can split cases base on instructions
            \begin{itemize}
                \item $Z(n)$. $r_n(x, j+1) = 0$, that is what we want.
                \item $S(n)$. $r_n(x, j+1) = r_n(x, j) + 1$, that by inductive hypothesis and by sum on naturals holds.
                \item $T(m, n)$. $r_n(x, j + 1) = r_m(x, j)$, that by inductive hypothesis holds.
            \end{itemize}
        \end{itemize}
        
        We have proven that all registers of a $URM^-$ machin, for each program $P$, keeps the form $c$ or $x + c$. From this we can conclude that $\calC^- \not\subseteq \calC$.
    \end{proof}
    
\end{exercise}


\end{document}
