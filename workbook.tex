% !TeX spellcheck = en_US
\documentclass[12pt,a4paper,oneside]{book}  
% oneside or openright

%% ***************************************************************
%%    PACKAGES
\usepackage{lmodern}         % font package.
\usepackage[T1]{fontenc}     % define T1 charset for out files.
\usepackage[english]{babel}  % italian latex typo conventions.
\usepackage[utf8]{inputenc}  % italian symbols.
\usepackage{csquotes}        % needed by babel.
\usepackage{amsmath}         % math features.
\usepackage{amsthm}          % math theorems.
\usepackage{amssymb}         % math symbols.
\usepackage{amsbsy}			 % math bold.
\usepackage{listings}        % embed programming language in latex.
\usepackage{stmaryrd}        % symbols for theoretical computer science.
\usepackage{hhline}          % better horizontal lines in tabulars and arrays.
%%\usepackage{vmargin}         % various page dimensions.
\usepackage{hyperref}        % hypertext support.
\usepackage{makeidx}         % for creating indexes.
\usepackage{nicefrac}        % inline fractions.
\usepackage{marginnote}      % notes in the margin, even where \marginpar fails.
\usepackage{xr}              % references to other latex documents.
\usepackage{subfiles}        % multifile support.
\usepackage{geometry}        % interface for document dimension.
\usepackage{graphicx}        % enhanced support for graphics.
\usepackage{fancyhdr}        % extensive control of page headers and footers.
\usepackage{lipsum}          % generate dummy text.
\usepackage[
backend=biber,
style=numeric,
citestyle=numeric  % numeric, alphabetic
]{biblatex}                  % bib management. %bibtex
\usepackage{minitoc}         % table of contents per chapter.
%\usepackage{titlesec}        % change titles size.
\usepackage{algorithm}       % algorithm block.
\usepackage{algcompatible}
\usepackage{algpseudocode}   % style for (autoimported) package algorithmicx.
\usepackage{float}           % float management.
\usepackage[toc,page]{appendix}  % appendix.
\usepackage{tcolorbox}
%\usepackage{minted}
\usepackage{tikz}            % flow chart.
%\usepackage{tocvsec2}        % numbering chapter fix.
\usepackage{enumitem}        % enums.
%\usepackage{subcaption}      % needed by nested figures.
%\usepackage{showframe}      % DEBUG: shows page frames.
\usepackage{xcolor}

%% ***************************************************************
%%    RESOURCES
\input{prooftree.tex}
\input{macros.tex}

%% ***************************************************************
%%    CONFIGURATIONS
\usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
	decorations.pathreplacing,decorations.pathmorphing,shapes,%
	matrix,shapes.symbols}
\tikzset{
	% flow chart
	>=stealth',
	punktchain/.style={
		rectangle,
		rounded corners,
		% fill=black!10,
		draw=black, very thick,
		text width=10em,
		minimum height=3em,
		text centered,
		on chain},
	line/.style={draw, thick, <-},
	element/.style={
		tape,
		top color=white,
		bottom color=blue!50!black!60!,
		minimum width=8em,
		draw=blue!40!black!90, very thick,
		text width=10em,
		minimum height=3.5em,
		text centered,
		on chain},
	every join/.style={->, thick,shorten >=1pt},
	decoration={brace},
	tuborg/.style={decorate},
	tubnode/.style={midway, right=2pt},
}

%% ***************************************************************
%%    OPENING
\title{Workbook \\ Master Degree in Computer Science}
\author{Luca Parolari\footnote{\href{mailto:luca.parolari23@gmail.com}{luca.parolari23@gmail.com}}}


%% ###############################################################
%%                            DOCUMENT
%% ###############################################################
\begin{document}

\maketitle
\tableofcontents

\part{AA 2019-2020}

% *********************
\chapter{Software Analysis and Verification}

\section{Exercises}

\subsection{Exercise 1.7}

\begin{exercise}{(1.7)}
	\label{ex_1_7}
	Prove that the equations of Equation \ref{eq_ex_1_7} define a total function $\calA$ in $\AExp \to (\ST \to \mathrm{Z})$: First argue that it is sufficient to prove that for each $a \in \AExp$ and each $s \in \ST$ there is exactly one value $v \in Z$ such that $\denotA{a}{s} = v$. Next use structural induction on the arithmetic expressions to prove that this is indeed the case.
	
	\begin{equation}
	\label{eq_ex_1_7}
	\begin{split}
	\denotA{n}{s} &= \denotN{n} \\
	\denotA{x}{s} &= s x \\
	\denotA{a_1+a_2}{s} &= \denotA{a_1}{s} + \denotA{a_2}{s} \\
	\end{split}
	\end{equation}
	
	\begin{proof}
		We have to prove that
		\[
		\forall a \in \AExp \itc \forall s \in \ST: \exists v \in \mathrm{Z} \st \denotA{a}{s} = v
		\]
		and we can do it by structural induction on $a$.
		
		\begin{itemize}
			\item Base case $a \equiv n$. $\denotA{n}{s} = \denotN{n}$ holds assuming $\denotN{n}$ is a total function.
			\item Base case $a \equiv x$. $\denotA{x}{s} = s x$ holds by definition of $s$ ($\fund{s}{\Var}{\Natural}$).
			\item Inductive case $a \equiv a_1 + a_2$. We can apply the definition for this case and we obtain
			\[
			\forall a_1, a_2 \in \AExp \itc \forall s \in \ST: \exists v \in \mathrm{Z} \st \denotA{a_1 + a_2}{s} = v
			\]
			and this, by structural induction and because $+$ is a total function, holds.
		\end{itemize}
	\end{proof}
	
\end{exercise}

\subsection{Exercise 1.8}

\begin{exercise}{(1.8)}
	Assume that $s\ x = 3$ and determine $\denotB{\notop(x = 1)}{s}$.
	
	\begin{proof}
		We have to apply rules from our semantics in order to get the result.
		
		TODO
	\end{proof}
\end{exercise}

\subsection{Exercise 1.9}

\begin{exercise}{(1.9)}
	Prove that the denotation semantic function for booleans $\calB$, $\fund{\calB}{\BExp}{(\ST \to \mathrm{T})}$ is total.
	
	\begin{proof}
		Identical to \ref{ex_1_7}
	\end{proof}
\end{exercise}

\subsection{Exercise 1.9}

\begin{exercise}{(1.9)}
	TODO
\end{exercise}

\subsection{Exercise 1.12}

\begin{exercise}
	Let $s$ and $s'$ be two states satisfying that $s x = s' x$ for all $x$ in $FV(b)$. Prove that $\denotB{b}{s} = \denotB{b}{s'}$. $\FV$ is defined in Definition \ref{ex_1_12_fv}.
	
	\begin{proof}
		We assume that this sentences holds for $\calA$. (This is proved in \ref{ex_1_12_lemma}). We have to prove that
		\[
		\forall b \in \BExp \itc \forall s, s' \in \ST \itc \forall x \in \FV(a) \itc sx = s'x \Rightarrow \denotB{b}{s} = \denotB{b}{s'}
		\]
		
	\end{proof}
	
\end{exercise}

\begin{definition}
	\label{ex_1_12_fv}
	Define FV \todo{define FV}
\end{definition}

\begin{lemma}
	\label{ex_1_12_lemma}
	\[
	\forall a \in \AExp \itc \forall s, s' \in \ST \itc \forall x \in \FV(a) \itc sx = s'x \Rightarrow \denotA{a}{s} = \denotA{a}{s'}
	\]
	
	\begin{proof}
		We have to prove that
		\[
		\forall a \in \AExp \itc \forall s, s' \in \ST \st sx = s'x \Rightarrow \denotA{b}{s} = \denotA{b}{s'}
		\]
		and we can do it by structural induction on $b$.
		
		\begin{itemize}
			\item Base case $a \equiv n$. It's trivial to note that $\denotA{n}{s} = \denotN{n} = n = n = \denotN{n} = \denotB{n}{s'}$.
			\item Base case $a \equiv x$. In this case we have
		\end{itemize}
	\end{proof}
\end{lemma}

% *********************
\chapter{Machine Learning}

\section{Decision Trees}

\subsection{Exercise: build a decision tree}

\begin{exercise}
	Using algorithm \emph{ID3} build the decision trees for logical AND, OR and XOR.
	
	\begin{proof} (AND)
		Define the examples set $S$ as
		\begin{center}
			\begin{tabular}{ c c c c }
				\textbf{Examples} & \textbf{$a_1$} & \textbf{$a_2$} & \textbf{Output} \\
				$E_1$ & 0 & 0 & $\ffv$ \\ 
				$E_2$ & 0 & 1 & $\ffv$ \\  
				$E_3$ & 1 & 0 & $\ffv$ \\
				$E_4$ & 1 & 1 & $\ttv$
			\end{tabular}
		\end{center}
		where $a_1, a_2$ are attributes in $A$, $\ttv, \ffv$ are the two possible classes and $0, 1$ are the two possible values.
		
		Now we can apply the algorithm \emph{ID3}.
		\begin{itemize}
			\item \textbf{Step 1} We create the root node $T$. The two tests fail: examples in $S$ are not in the same class and $A$ is not empty. So we have to chose $a \in A$ as the best attribute in $A$.
			
			In order to chose the best attribute in $A$ we must calculate the \emph{entropy} (i.e., a measure of the disorder) and the \emph{information gain} (i.e., the expected reduction of entropy for a given set).
			
			Entropy is
			\[
			E(S) = - \sum_{c=1}^{m} p_c \log(p_c)
			\]
			where $p_c = \frac{|S_c|}{|S|}$, but for a binary classification it becomes
			\[
			E(S) = - p_- \log(p_-) - p_+ \log(p_+)
			\]
			
			And the gain
			\[
			G(S,a) = E(S) - \sum_{v\in V(a)} \frac{|S_{a=v}|}{|S|} E(S_{a=v})
			\]
			
			So, instancing the two formulas on our data we obtain
			\[
			p_- = \frac{|S_-|}{|S|} = \frac{3}{4} \qquad p_+ = \frac{|S_+|}{|S|} = \frac{1}{4}
			\]
			and
			\[
			E(S) = - \frac{3}{4} \log\big(\frac{3}{4}\big) - \frac{1}{4} \log\big(\frac{1}{4}\big) = 0.244
			\]
			From this, we can calculate the gain as
			\begin{equation*}
			\begin{split}
			G(S, a_1) &= 0.244 - \Big( \big(\frac{|S_{a_1=0}|}{|S|} E(S_{a_1=0})\big) + \big(\frac{|S_{a_1=1}|}{|S|} E(S_{a_1=1})\big) \Big) \\
			&= 0.244 - \Big( \big(\frac{2}{4} E(S_{a_1=0})\big) + \big(\frac{2}{4} E(S_{a_1=1})\big) \Big) \\
			&= 0.244 - (0 + 0.25) \\
			&= -0.006  \law{\color{red}{WTF??}}
			\end{split}
			\end{equation*}
			\fixme{Non pu√≤ essere negativo!}
			
			From the above we can chose the attribute $a_1$, set it as $T$ and make two recursive call:
			\begin{itemize}
				\item $ID3(S_{a_1=0}, A \setdiff \{a_1\})$
				\item $ID3(S_{a_1=1}, A \setdiff \{a_1\})$
			\end{itemize}
			
			\item \textbf{Step 2} First recursive call from Step 1. We have $S = \{ \langle 0,0,\ffv \rangle, \langle 0,1,\ffv \rangle \}$, $A = \{a_2\}$. We create a new root node $T$ and we can assign $\ffv$ to it because the elements in $S$ have the same class.
			
			\item \textbf{Step 3} Second recursive call from Step 1. We have $S = \{ \langle 1,0,\ffv \rangle, \langle 1,1,\ttv \rangle \}$, $A=\{a_2\}$. We create a new root node $T$ and assign $a_2$ to it because $a_2$ is the last attribute in $A$ (i.e., the optimal one), then we can make the recursive call:
			\begin{itemize}
				\item $ID3(S_{a_2=0}, A \setdiff \{a_2\})$
				\item $ID3(S_{a_2=1}, A \setdiff \{a_2\})$
			\end{itemize}
			
			\item \textbf{Step 4} First recursive call from Step 3. We have $S=\{\langle 1,0,\ffv \rangle \}$ and for this we can assign $\ffv$ to $T$ since it is the last element in $S$, making a leaf.
			
			\item \textbf{Step 5} Second recursive call from Step 3. We have $S=\{ \langle 1,1,\ttv \rangle \}$ and for this we can assign $\ttv$ to $T$ since it is the last element in $S$, making a leaf.
		\end{itemize}
		
		\begin {tikzpicture}[-latex ,auto ,node distance =2 cm and 2cm, on grid, semithick, state/.style ={ circle ,top color =white , bottom color = white, draw, black , text=black, minimum width =1 cm}]
		\node[state] (A) {$a_1$};
		\node[state] (B) [below left =of A] {$\ffv$};
		\node[state] (C) [below right =of A] {$a_2$};
		\node[state] (D) [below left =of C] {$\ffv$};
		\node[state] (E) [below right =of C] {$\ttv$};
		\path (A) edge node {$0$} (B);
		\path (A) edge node {$0$} (C);
		\path (C) edge node {$0$} (D);
		\path (C) edge node {$1$} (E);
	\end{tikzpicture}
	
\end{proof}
\end{exercise}

\begin{exercise}
Using algorithm \emph{ID3} build the decision trees for logical AND, OR and XOR. This time only three examples are given.

\begin{proof} (AND)
	Define the examples set $S$ as
	\begin{center}
		\begin{tabular}{ c c c c }
			\textbf{Examples} & \textbf{$a_1$} & \textbf{$a_2$} & \textbf{Output} \\
			$E_1$ & 0 & 0 & $\ffv$ \\
			$E_2$ & 0 & 1 & $\ffv$ \\
			$E_4$ & 1 & 1 & $\ttv$ \\
		\end{tabular}
	\end{center}
	where $a_1, a_2$ are attributes in $A$, $\ttv, \ffv$ are the two possible classes and $0, 1$ are the two possible values.
	
	Now we can apply the algorithm \emph{ID3}.
	\begin{itemize}
		\item \textbf{Step 1} We create the root node $T$. The two tests fail: examples in $S$ are not in the same class and $A$ is not empty. So we have to chose $a \in A$ as the best attribute in $A$.
		
		For simplicity this part is skipped and $a_1$ is chosen as the optimal attribute.
		
		From the above we can chose the attribute $a_1$, set it as $T$ and make two recursive call:
		\begin{itemize}
			\item $ID3(S_{a_1=0}, A \setdiff \{a_1\})$
			\item $ID3(S_{a_1=1}, A \setdiff \{a_1\})$
		\end{itemize}
		
		\item \textbf{Step 2} First recursive call from Step 1. We have $S = \{ \langle 0,0,\ffv \rangle, \langle 0,1,\ffv \rangle \}$, $A = \{a_2\}$. We create a new root node $T$ and we can assign $\ffv$ to it because the elements is $S$ are have the same class.
		
		\item \textbf{Step 3} Second recursive call from Step 1. We have $S = \{ \langle 1,1,\ttv \rangle \}$, $A=\{a_2\}$. We create a new root node $T$ and assign $\ttv$ to it because elements in $S$ have the same class.
	\end{itemize}
\end{proof}
\end{exercise}

\end{document}
